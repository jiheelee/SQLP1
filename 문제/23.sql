/* 아래 SQL을 OLTP에 최적화 하여 튜닝 하세요.  (인덱스 및 SQL 수정 가능)
   최종 결과 값 : 18건
   
   T_고객23 
      - 총건수               : 2만건
      - 고객성향코드 = '920' : 101건
      - 고객성향코드 종류    : 200종류      
      - 인덱스 : PK_T_고객23 (고객번호)

   T_주문23
      - 총 건수: 200만건
      - 아래 조건의 결과 : 10,000건
        O.주문일자 LIKE '201701%' AND O.상품코드 = 'P103'   
      - 인덱스 : PK_T_주문23 (주문번호)   */

ALTER SESSION SET STATISTICS_LEVEL = ALL;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST'));
/* 튜닝 전 */
SELECT /*+ GATHER_PLAN_STATISTICS */ 
       C.고객번호, C.고객명, C.C1,
       O.주문번호, O.상품코드, O.주문일자, O.주문수량
FROM T_고객23 C, T_주문23 O
WHERE C.고객성향코드 = '920'
 AND  O.고객번호     = C.고객번호
 AND  O.주문일자     LIKE '201701%'
 AND  O.상품코드     = 'P103';

/*
PLAN_TABLE_OUTPUT
---------------------------------------------------------------------------------------------------------------------------
| Id  | Operation          | Name   | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem | Used-Mem |
---------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |        |      1 |        |     13 |00:00:00.11 |   11281 |    166 |       |       |          |
|*  1 |  HASH JOIN         |        |      1 |     99 |     13 |00:00:00.11 |   11281 |    166 |   756K|   756K| 1196K (0)|
|*  2 |   TABLE ACCESS FULL| T_고객2|      1 |     90 |     97 |00:00:00.01 |     459 |      0 |       |       |          |
|*  3 |   TABLE ACCESS FULL| T_주문2|      1 |   4001 |   3013 |00:00:00.11 |   10822 |    166 |       |       |          |
---------------------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - access("O"."고객번호"="C"."고객번호")
   2 - filter("C"."고객성향코드"='920')
   3 - filter(("O"."상품코드"='P103' AND "O"."주문일자" LIKE '201701%')) */

CREATE INDEX IX_T_고객23 ON T_고객23(고객성향코드);
CREATE INDEX IX_T_주문23 ON T_주문23(고객번호, 상품코드, 주문일자);

/* 튜닝 후 */
SELECT /*+ GATHER_PLAN_STATISTICS LEADING(C) USE_NL(C O) INDEX(C IX_T고객23) INDEX(O IX_T주문23) */ 
       C.고객번호, C.고객명, C.C1,
       O.주문번호, O.상품코드, O.주문일자, O.주문수량
FROM T_고객23 C, T_주문23 O
WHERE C.고객성향코드 = '920'
 AND  O.고객번호     = C.고객번호
 --AND  O.주문일자     BETWEEN '20170101' AND '20170131'
 AND  O.주문일자     LIKE '201701%'
 AND  O.상품코드     = 'P103';

/*
--------------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name      | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
--------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |           |      1 |        |     13 |00:00:00.01 |     300 |      1 |
|   1 |  NESTED LOOPS                 |           |      1 |        |     13 |00:00:00.01 |     300 |      1 |
|   2 |   NESTED LOOPS                |           |      1 |    107 |     13 |00:00:00.01 |     287 |      0 |
|   3 |    TABLE ACCESS BY INDEX ROWID| T_고객23  |      1 |     97 |     97 |00:00:00.01 |      90 |      0 |
|*  4 |     INDEX RANGE SCAN          | IX_T_고객2|      1 |     97 |     97 |00:00:00.01 |       2 |      0 |
|*  5 |    INDEX RANGE SCAN           | IX_T_주문2|     97 |      1 |     13 |00:00:00.01 |     197 |      0 |
|   6 |   TABLE ACCESS BY INDEX ROWID | T_주문23  |     13 |      1 |     13 |00:00:00.01 |      13 |      1 |
--------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - access("C"."고객성향코드"='920')
   5 - access("O"."고객번호"="C"."고객번호" AND "O"."상품코드"='P103' AND "O"."주문일자">='20170101' AND 
              "O"."주문일자"<='20170131')
*/

/*
튜닝 포인트
1. OLTP 환경에서는 HASH, MERGE JOIN 보다 NL 조인이 효과적이다.
  - 부분범위 처리
  - 인덱스를 이용할 수 있음
  - MULTI BLOCK 으로 읽은 것은 버퍼캐시에서 더 빨리 밀려남
2. INDEX를 ACCESS로 태운다.
  - OUTER TABLE 의 인덱스 효율은 특히 중요하다. INNER 테이블 건수만큼 INDEX를 태우기 때문에
  - =조건을 선두로 해주는 것이 좋다
3. LIKE 를 BETWEEN으로 변경
  - 바꿔서 손해볼 것은 없다. 다만, 주문일자가 결합 인덱스의 마지막 순서이기 때문에 효과가 별로 크진 않았음
*/