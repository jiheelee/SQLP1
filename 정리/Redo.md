## REDO

오라클은 데이터파일과 컨트롤 파일에 가해지는 모든 변경사항을 하나의 Redo 로그 엔트리로서 Redo 로그에 기록한다.

Redo 로그는 Online Redo와 Archived(=Offline) Redo 로그로 구성된다.

Online Redo 로그는 Redo 로그 버퍼에 버퍼링된 로그 엔트리를 기록하는 파일로서, 최소 두개 이상의 파일로 구성된다.

현재 사용 중인 Redo 로그 파일이 꽉 차면 다음 Redo 로그 파일로 로그 스위칭이 발생하며, 계속 Redo 로그를 써 나가다가 모든 Redo 로그 파일이 꽉 차면 다시 첫 번째 Redo 로그 파일부터 재사용하는 라운드 로빈(round-robin) 방식을 사용한다.

Archived Redo 로그는 Online Redo 로그가 재사용되기 전에 다른 위치로 백업해 둔 파일을 말한다.

Redo로그는 아래 3가지 목적을 위해 사용한다.

1. Database Recovery
2. Cache Recovery
3. Fast commit



첫째, Redo 로그는 물리적으로 디스크가 깨지는 등의 Media Fail 발생시 데이터베이스를 복구하기 위해 사용되면, 이때는 Archived Redo 로그를 이용하게 된다.

둘째, Redo 로그는 Cache Recovery 를 위해 사용되며 다른 말로 'Instance Recovery'라고도 한다. 모든 데이터베이스 시스템이 버퍼 캐시를 도입하는 ㄴ것은 I/O 성능을 향상시키기 위함이지만, 버퍼 캐시는 휘발성이다.따라서 캐시에 저장된 변경사항이 디스크 상의 데이터 블록에 아직 기록되지 않은 상태에서 정전 등이 발생해 인스턴스가 비정상적으로 종료되면, 그때까지의 작업내용을 모두 잃게 된다. 이러한 트랜잭션 데이터의 유실에 대비하기 위해 Redo 로그를 사용한다.

Instance Crash 발생 후 시스템을 재기동하면 우선 Online Redo 로그에 저장된 기록 사항들을 읽어들여 마지막 체크포인트 이후부터 사고 발생 직전까지 수행되었던 트랜잭션들을 재현한다. 그러면 버퍼 캐시에만 수정하고 데이터파일에는 반영되지 않았던 변경사항들이 복구되면, 이는 트랜잭션의 커밋여부를 불문하고 일단 버퍼 캐시를 시스템이 셧다운 되기 이전 상태로 되돌리는 것이다.



Cache Recovery 가 완료되면 뒤에서 설명할 Undo 데이터를 이용해 시스템이 셧다운되는 시점에 아직 커밋되지 않았던 트랜잭션들을 모두 롤백하는, 이른바 Transaction Recovery 가 진행된다. 이렇게 roll forward 와 rollback단계를 모두 완료하고 나면 커밋되지 않은 기록사항들은 모두 제거되어 데이터파일에는 커밋에 성공한 데이터만 남게 되며, 데이터베이스는 완전히 동기화된 상태가 된다.



마지막으로, Redo로그는 Fast Commit 을 위해 사용된다. 변경된 메모리 버퍼 블록을 디스크 상의 데이터 블록에 기록하는 작업은 Random 액세스 방시긍로 이루어지기 때문에 느리기 마련이다. 반면 로그는 Append 방식으로 기록하므로 상대적으로 매우 빠르다. 따라서 트랜잭션 발생시 건건이 데이터 파일에 기록하기보다 우선 변경사항을 Append 방식으로 빠르게 로그 파일에 기록하고 메모리 데이터 블로과 데이터 파일간 동기화는 적절한 수단을 이용해 나중에 배치 방식으로 일괄 수행한다.

사용자의 갱신내용이 메모리상의 버퍼 블록에만 기록된 채 아직 디스크에 기록되지 않았지만 Redo 로그를 믿고 빠르게 커밋을 완료한다는 의미에서, 이런 매커니즘을 fast commit 이라고 부른다. 적어도 커밋 정보가 로그에 기록돼 있기만 하다면 인스턴스 Crash가 발생하더라도 Redo 로그를 이용해 언제든 Recovery 가 가능한 상태가 되므로 오라클은 안심하고 커밋을 완료할 수 있는 것이다.

Fast Commit은 오라클에만 잇는 기능이 아니며, 빠르게 트랜잭션을 처리해야 하는 모든 DBMS 의 공통적인 메커니즘이다. 