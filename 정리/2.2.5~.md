### 2.2.5 ORDER BY 절에서 컬럼 가공

보통 INDEX 사용시 그 결합 인덱스 순서대로 조회하고 정렬하면,

SORT 연산없이 조회된다.

그러나, ORDERY BY 절이 가공이 된다면?

CASE 1) ORDER BY 컬럼1||컬럼2 => 인덱스를 쓸 수 없음

CASE 2) SELECT 절에서 가공한 컬럼을 가지고 ORDER BY 를 하려고 하면 인덱스 쓸 수 없음.

​               SELECT 절에서 가공하더라도 그 테이블의 컬럼으로 ORDER BY 를 한다는 것을 잘 명시해주면 괜찮음



Q. ORDER BY 1 => 이렇게 하면 가능할까?



###  2.2.6  SELECT-LIST에서 컬럼가공

MIN, MAX는 INDEX로 자동 정렬 가능!

하지만 다른 방식으로 가공 한걸 MIN or MAX 한다면? 인덱스 쓸 수 없음

그래서 웬만하면 MIN or MAX 먼저 싸고 그 다음에 가공을 해라 p101 에 예시 있음



두개의 컬럼의 MAX를 구해야 한다면 어떻게 해야할까?

방법 1. 서브쿼리 여러개를 이용하여 구한다..

=> 인덱스를 탈 수 있지만, 쿼리가 길어지고 테이블을 여러 번 읽을 수 있음

방법 2. MAX(컬럼1||컬럼2)

=> 쿼리는 짧지만, 데이터가 많으면 엄청 오래 걸림



================5장의 내용===================================

방법 3. INDEX를 이용해 DESCENDING INDEX를 적용하고, ROWNUM 을 줘서 마지막 꺼만 가져온다

=> 쿼리도 짧고 성능도 좋지만, 인덱스 구성이 바뀔 경우 결과가 다르게 나와버림

방법 4. INDEX 를 이용하는데 SUB 쿼리 안에 하나 더 넣어서 ORDER BY 컬럼1, 컬럼2 이렇게 넣고,

바깥 서브쿼리에서 ROWNUM 으로 제어, 메인 쿼리랑 잇는 컬럼 조인도 바깥 서브 쿼리에서 하면,

바깥 서브쿼리에서 안 서브쿼리로 조건이 Predicate Pushing이 됨.



### 2.2.7 자동 형변환

날짜형, 숫자형 > 문자형 

좌변이 더 우선순위가 낮으면 좌변이 가공되어버릴 수 있음

생년월일 > 19951117

TO_NUMBER(생년월일) 되어버림



좌변의 우선순위가 더 높으면 우변이 가공되어 인덱스를 타는데 문제가 없지만

NLS_DATE_FORMAT 파라미터가 다르게 설정된 환경에서 수행하면 컴파일 오류가 나거나 결과집합이 틀려질 수 있음

또한 숫자형으로 바뀌는 값이 숫자로 바뀔 수 없는 문자형이면 도중 에러가 발생함



숫자형이 보통 문자형을 이기지만 LIKE 일 때는 다르다!!



LIKE 를 해버리면 자동으로 문자형으로 처리하게됨..



그래서 LIKE 를 쓰기 보다 두개의 쿼리로 나누는 게 나음

ACCNO LIKE :accno

:accno = '%'

:accno = 6546453132



 decode(a, b, c, d)

에서 c의 형태가 중요함, null 이라면 d 도 문자열로 나옴



형변환은 무조건 써주어야함!!!



