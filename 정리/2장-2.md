## 2.2 인덱스 기본 사용법

인덱스 기본 사용법 : Range Scan

인덱스 확장 기능     : Range Scan 외 다른 다양한 스캔 방식(skip scan, fast full scan 등)

### 2.2.1 인덱스를 사용한다는 것

인덱스가 좋은 이유 : 정렬되어 있기 때문에!

But, 인덱스 중간에 찾는 값이 있는 경우? 인덱스 전체를 스캔해야 함

=> 조회하는 조건이 결합인덱스의 선행 컬럼이 아닐 경우, 인덱스 전체를 스캔해야해서 효율이 좋지 않음

=> 가공해도 인덱스 전체를 스캔함

(리프블록 전체를 스캔한다는 의미)



### 2.2.2 인덱스를 Range Scan 할 수 없는 이유  

인덱스 Range Scan 의 핵심!

-> 일정 범위 스캔, 시작점과 끝점이 있어야 함



인덱스에 가공된 값으로 존재하지 않으니, 인덱스 매커니즘에서는 찾을 수 없고,

그래서 Index Full Scan 해야만함

기본적으로 substr, nvl, like, or, in 은 index range scan이 불가하나, in과 or은 쿼리변환 기능을 통해 index range scan으로 쓸 수도 있음!!!



Q. 컬럼1||컬럼2 = '대한민국' 이런 식으로 하는 건 인덱스를 탈 수 있을까?



1) LIKE 연산의 경우, 해당 검색어로 시작하는 경우, 대한% 가능,

중간값 %민국 -> 찾을 수 없음



2) OR 연산의 경우, Range 스캔을 할 수 없음.

use_concat을 이용해 => OR Expansion을 유도 했을 때는 다름

or Expansion 이 들어가면 union all 로 들어가는 거랑 똑같음



3) IN 조건은 OR 조건의 다른 표현 방식임,

​    그래서 union all 로 바꾸면 index를 각각 탈 수 있고,

​    이것과 비슷하게 동작하게 해주는 방식이 IN-List Iterator이다

​     IN-LIST 개수만큼 Index Range Scan 을 반복!!!



Q1. 테이블 조회시, 인덱스에 포함된 두 컬럼에 대해서 >, < 로 조회하고 있다.

순서가 중요한가?



### 2.2.3 더 중요한 인덱스 사용 조건

선두컬럼이 무조건 조건절에 있어야함.

왜? 결합인덱스는 선두컬럼으로 시작하기 때문에 두번째 인덱스를 읽으려면 시작점을 알 수 없음

=> Index Range Scan 은 시작점, 끝점을 아는게 핵심이기 때문에 이런 경우엔 필요없음



결론 : 인덱스의 선두 컬럼이 가공되지 않은 상태로 조회되어야 함

인덱스 잘 타니까 튜닝 끝? 

첫번째 컬럼이 변별력이 있는게 중요함, RANGE SCAN을 하기로 했는데,

첫번째 컬럼이 변별력 없고, 두번째 컬럼도 인덱스를 사용할 수 없도록 가공되어 있다면,

차라리 INDEX FULL SCAN 하는 게 나음.

수직적 탐색이 오래 걸리기 때문에, INDEX FULL SCAN은 그래도 MULTI BLOCK I/O라도 하지...



Q2. 선두 컬럼이 조건절에 없을 때, 무조건 INDEX FULL SCAN 이 좋은걸까?

INDEX SKIP SCAN 의 동작 방식은 어떻길래, 이런 조건에도 불구하고 쓰는 걸까?

조건절에 좋은 선두 컬럼(선택도가 낮은)이 있으면 당연히 INDEX RANGE SCAN이 좋겠지만,

SKIP 을 많이 안 해도 되는 경우, 선두 컬럼이 변별력이 없을 때, 두번째 컬럼이 선택도가 낮은 컬럼일 경우 SKIP SCAN이 좋을 수 있음



### 2.2.4 인덱스를 이용한 소트 연산 생략

Index Range Scan이 좋은 이유는 정렬이 되어 있어

시작점에서 출발하여 어떠한 끝점에서 멈출 수 있고, 그래서 데이터를 일부만 읽어도 된다는 것이 장점이었다.

그렇다면 index를 이용해 추출할 때 index 순서대로 자동으로 정렬되어서 나올 것이다. 엑셀 정렬하듯.

그래서 order by 를 쓴다면, 무조건 sort 연산이 따로 들어가는 게 아니라,

인덱스 정렬된 순서에 맞게 order by 를 쓴다면 sort 연산이 들어가지 않는다.



1) ascending order by 는 가장 작은 값을 찾아 좌측으로 수직 탐색한 후, 우측으로 수평탐색함

2) descending order by 는 가장 큰 값을 찾아 우측으로 수직 탐색한 후, 좌측으로 수평탐색함



