양쪽 집합을 개별적으로 읽고 나서 조인을 시작한다는 특징도 있다.
따라서 조인 컬럼에 인덱스가 없는 상황에서 두 테이블을 각각 읽어 조인 대상 집합을 줄일 수 있을 떄 아주 유리하다					
SORT MERGE JOIN 은 조인컬럼에 인덱스가 없는 상황에서 유리하다! 라는 말이 정확히 어떤 의미인지?



1. 선행 테이블에 인덱스가 있으면 굳이 SORT 하지 않아도 되기 때문에 이득이다?
2. NO_MERGE 를 하는 이유는 GROUP BY 테이블에서 건수가 너무 많이 나와 
불필요하게 다른 테이블과 많이 조인되는 것을 막기 위해 독립적으로 VIEW를 만들어서 다른 WHERE 조건들로 먼저 줄여주기 위해 하는 건데,
GROUP BY 테이블의 건수가 많지 않거나, 조인 컬럼으로 많이 줄일 수 있는 경우라면 굳이 안 하는 게 낫다.
PUSH_PRED를 하면 NO_MERGE를 하는 효과가 상쇄되는데(선행이 바뀌면서 조인 횟수를 줄이지 못하니깐), 부분처리를 할 경우에는
PUSH_PRED를 해주는 게 좋다.

선행테이블에서 미리 필터링된 건수가 적고, GROUP BY 테이블 조회 건수가 적은 경우
=> 그냥 일반 조인

선행테이블에서 미리 필터링된 건수가 많고, GROUP BY 테이블 조회 건수가 많은 경우
=> NO_MERGE

선행테이블에서 미리 필터링된 건수가 적고, GROUP BY 테이블 조회 건수가 많은 경우
=> NO_MERGE PUSH_PRED

선행테이블에서 미리 필터링된 건수가 많고, GROUP BY 테이블 조회 건수가 적은 경우
=> 그냥 일반 조인

선행테이블에서 미리 필터링된 건수가 많고, GROUP BY 테이블 조회 건수가 많지만 부분처리가 필요할때 
=> NO_MERGE PUSH_PRED
 

괄호 안에 있는 걸 먼저해서 조인을 줄여주기 위해 하는 건데,

PUSH_PRED

NO_MERGE 는 괄호 안에 있는 걸 먼저 한다.!
PUSH_PRED

VIEW에 있는 걸 먼저 줄이고, 부분처리를 하기 위해서..

VIEW


3. 친절한 sql p312 => 아래 쿼리에서 부분처리가 불가한 이유는? 고객번호를 rownum 만큼만 뽑으면 되지 않나유?
   => 조인에 성공한 전체 집합을 group by 하고서야 출력할 수 있따???? 이해가 안 됨

4. 52번 파티션 테이블은 nl 조인으로 하는 게 비효율적인가?
-